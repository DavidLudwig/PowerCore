add

011111 RT RA RB OE 100001010 Rc
0      6  11 16 21 22        31

    int64_t val = (int64_t)(int32_t)r[RA] + (int64_t)(int32_t)r[RB];
    r[RT] = val;
    if(OE) overflow(val);
    if(Rc) record(0,val);
  
===

addc

011111 RT RA RB OE 000001010 Rc
0      6  11 16 21 22        31

    int64_t val = (int64_t)(int32_t)r[RA] + (int64_t)(int32_t)r[RB];
    r[RT] = val;
    if(OE) overflow(val);
    if(Rc) record(0,val);
    CA = (val >> 32) & 1;
  
===

adde

011111 RT RA RB OE 010001010 Rc
0      6  11 16 21 22        31

    int64_t val = (int64_t)(int32_t)r[RA] + (int64_t)(int32_t)r[RB] + (CA ? 1 : 0);
    r[RT] = val;
    if(OE) overflow(val);
    if(Rc) record(0,val);
    CA = (val >> 32) & 1;
  
===

addi

00111 S RT RA SI
0     5 6  11 16

    r[RT] = (RA ? r[RA] : 0) + ((int16_t)SI << (S ? 16 : 0));

===

addic

00110 Rc RT RA SI
0     5  6  11 16

    int64_t val = (int64_t)(int32_t)(RA ? r[RA] : 0) + (int16_t)SI;
    if(Rc) record(0,val);
    CA = (val >> 32) & 1;

===

addme

011111 RT RA 00000 OE 011101010 Rc
0      6  11 16    21 22        31

    int64_t val = (int64_t)(int32_t)r[RA] + (int64_t)-1 + (CA ? 1 : 0);
    r[RT] = val;
    if(OE) overflow(val);
    if(Rc) record(0,val);
    CA = (val >> 32) & 1;
  
===

addze

011111 RT RA 00000 OE 011001010 Rc
0      6  11 16    21 22        31

    int64_t val = (int64_t)(int32_t)r[RA] + (CA ? 1 : 0);
    r[RT] = val;
    if(OE) overflow(val);
    if(Rc) record(0,val);
    CA = (val >> 32) & 1;
  
===

and

011111 RS RA RB 0000011100 Rc
0      6  11 16 21         31

    uint32_t val = r[RS] & r[RB];
    r[RA] = val;
    if(Rc) record(0,val);

===

andc

011111 RS RA RB 0000111100 Rc
0      6  11 16 21         31

    uint32_t val = r[RS] & ~r[RB];
    r[RA] = val;
    if(Rc) record(0,val);

===

andi

01110 S RS RA UI
0     5 6  11 16

    uint32_t val = r[RS] & (UI << (S ? 16 : 0));
    r[RA] = val;

===

// b, ba, bl, bla

b
010010 LI AA LK
0      6  30 31

    if(LK) lr = NIA;
    int32_t val = LI << 2;
    if(val & 0x02000000)
        val |= 0xFC000000;
    NIA = (AA ? 0 : CIA) + val;

===
// be, bea, bel, bela

bc
010000 BO BI BD AA LK
0      6  11 16 30 31

    if(LK) lr = NIA;
    if(conditional(BO, BI))
        NIA = (AA ? 0 : CIA) + (int16_t) (BD<<2);

===
// bce, ...

bcctr
010011 BO BI 00000 1000010000 LK
0      6  11 16    21         31

    if(LK) lr = NIA;
    if(conditional(BO | 0x4, BI))
        NIA = ctr & ~3;

===
bclr

010011 BO BI 00000 0000010000 LK
0      6  11 16    21         31

    if(LK) lr = NIA;
    if(conditional(BO, BI))
        NIA = lr & ~3;

===

cmp

011111 BF 0 L  RA RB 0000000000 0
0      6  9 10 11 16 21         31

    record(BF, r[RA] - r[RB]);

===
cmpi

001011 BF 0 L  RA SI
0      6  9 10 11 16

    record(BF, r[RA] - (int16_t)SI);

===
cmpl

011111 BF 0 L  RA RB 0000100000 0
0      6  9 10 11 16 21         31

    if(r[RA] == r[RB])
        setcr(BF, 2 | SO);
    else if(r[RA] < r[RB])
        setcr(BF, 8 | SO);
    else
        setcr(BF, 4 | SO);

===
cmpli

001010 BF 0 L  RA SI
0      6  9 10 11 16

    if(r[RA] == SI)
        setcr(BF, 2 | SO);
    else if(r[RA] < SI)
        setcr(BF, 8 | SO);
    else
        setcr(BF, 4 | SO);

===
cntlzw

011111 RS RA 00000 0000011010 Rc
0      6  11 16    21         31

    uint32_t val = __builtin_clz(r[RS]);
    r[RA] = val;
    if(Rc) record(0,val);

===
crand

010011 BT BA BB 0100000001 0
0      6  11 16 21         31

    crbit(BT, crbit(BA) && crbit(BB));

===
crandc

010011 BT BA BB 0010000001 0
0      6  11 16 21         31

    crbit(BT, crbit(BA) && !crbit(BB));

===
creqv

010011 BT BA BB 0100100001 0
0      6  11 16 21         31

    crbit(BT, crbit(BA) == crbit(BB));

===
crnand

010011 BT BA BB 0011100001 0
0      6  11 16 21         31

    crbit(BT, !(crbit(BA) && crbit(BB)));

===
crnor

010011 BT BA BB 0000100001 0
0      6  11 16 21         31

    crbit(BT, !(crbit(BA) || crbit(BB)));

===
cror

010011 BT BA BB 0111000001 0
0      6  11 16 21         31

    crbit(BT, crbit(BA) || crbit(BB));

===
crorc

010011 BT BA BB 0110100001 0
0      6  11 16 21         31

    crbit(BT, crbit(BA) || !crbit(BB));

===
crxor

010011 BT BA BB 0011000001 0
0      6  11 16 21         31

    crbit(BT, crbit(BA) != crbit(BB));

===
dcba

011111 00000 RA RB 101111 E  110 0
0      6     11 16 21     27 28  31

    ;

===
dcbf

011111 00000 RA RB 000101 E  110 0
0      6     11 16 21     27 28  31

    ;

===
dcbst

011111 00000 RA RB 000011 E  110 0
0      6     11 16 21     27 28  31

    ;

===
dcbt

011111 CT RA RB 010001 E  110 0
0      6  11 16 21     27 28  31

    ;

===
dcbtst

011111 CT RA RB 001111 E  110 0
0      6  11 16 21     27 28  31

    ;

===
divw

011111 RT RA RB OE 111101011 Rc
0      6  11 16 21 22        31

    int32_t val = (int32_t)r[RA] / (int32_t)r[RB];
    r[RT] = val;
    if(OE)
    {
        OV = (r[RA] == 0x80000000 && r[RB] == 0xFFFFFFFF)
            || r[RB] == 0;
        SO = SO || OV;
    }
    if(Rc) record(0, val);

===
divwu

011111 RT RA RB OE 111001011 Rc
0      6  11 16 21 22        31

    int32_t val = r[RA] / r[RB];
    r[RT] = val;
    if(OE)
    {
        OV = r[RB] == 0;
        SO = SO || OV;
    }
    if(Rc) record(0, val);
===
eqv

011111 RS RA RB 0100011100 Rc
0      6  11 16 21         31

    int32_t val = ~(r[RS] ^ r[RB]);
    r[RA] = val;
    if(Rc) record(0, val);
===
extsb

011111 RS RA 00000 1110111010 Rc
0      6  11 16    21         31

    int32_t val = (int8_t)r[RS];
    r[RA] = val;
    if(Rc) record(0, val);
===
extsh

011111 RS RA 00000 1110011010 Rc
0      6  11 16    21         31

    int32_t val = (int16_t)r[RS];
    r[RA] = val;
    if(Rc) record(0, val);
===
icbi

011111 00000 RA RB 1111010110 0
0      6     11 16 21         31

    ; // TODO: flush cache

===
icbt

011111 CT RA RB 0000010110 0
0      6  11 16 21         31

    ;

===

isync

010011 000000000000000 0000010110 0
0      6               21         31

    ;

===
lbz

10001 U RT RA D
0     5 6  11 16

    uint32_t ea = (RA ? r[RA] : 0) + (int16_t)D;
    r[RT] = load<uint8_t>(ea);
    if(U) r[RA] = ea;

===
lbzx

011111 RT RA RB 0001 U  10111 0
0      6  11 16 21   25 26    31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    r[RT] = load<uint8_t>(ea);
    if(U) r[RA] = ea;

===
lha

10101 U RT RA D
0     5 6  11 16

    uint32_t ea = (RA ? r[RA] : 0) + (int16_t)D;
    r[RT] = (int32_t) load<int16_t>(ea);
    if(U) r[RA] = ea;

===
lhax

011111 RT RA RB 0101 U  10111 0
0      6  11 16 21   25 26    31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    r[RT] = (int32_t) load<int16_t>(ea);
    if(U) r[RA] = ea;

===
lhbrx

011111 RT RA RB 1100010110 0
0      6  11 16 21         31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    r[RT] = swap16( load<uint16_t>(ea) );

===
lwbrx

011111 RT RA RB 1000010110 0
0      6  11 16 21         31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    r[RT] = swap32( load<uint32_t>(ea) );

===
lhz

10100 U RT RA D
0     5 6  11 16

    uint32_t ea = (RA ? r[RA] : 0) + (int16_t)D;
    r[RT] = load<uint16_t>(ea);
    if(U) r[RA] = ea;

===
lhzx

011111 RT RA RB 0100 U  10111 0
0      6  11 16 21   25 26    31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    r[RT] = load<uint16_t>(ea);
    if(U) r[RA] = ea;

===
lwz

10000 U RT RA D
0     5 6  11 16

    uint32_t ea = (RA ? r[RA] : 0) + (int16_t)D;
    r[RT] = load<uint32_t>(ea);
    if(U) r[RA] = ea;

===
lwzx

011111 RT RA RB 0000 U  10111 0
0      6  11 16 21   25 26    31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    r[RT] = load<uint32_t>(ea);
    if(U) r[RA] = ea;

===
mcrf

010011 BF 00 BFA 0000000 0000000000 0
0      6  9  11  14      21         31

    setcr(BFA, getcr(BF));

===
mfcr

011111 RT 0000000000 0000010011 0
0      6  11         21         31

    r[RT] = cr;

===
mcrxr

011111 BF 000000000000 1000000000 0
0      6  9            21         31

    ; // TODO

===
mflr

011111 RT 01000 00000 0101010011 0
0      6  11    16    21         31

    r[RT] = lr;

===
mfctr

011111 RT 01001 00000 0101010011 0
0      6  11    16    21         31

    r[RT] = ctr;

===
msync

011111 000000000000000 1001010110 0
0      6               21         31

    ;

===
mtcrf

011111 RS 0  FXM 0  0010010000 0
0      6  11 12  20 21         31

    for(int i = 0; i < 8; i++)
        if(FXM & (1>>i))
            setcr(i, (r[RS] >> (7-i) * 4) & 0xF);

===
mtlr

011111 RS 01000 00000 0111010011 0
0      6  11    16    21         31

    lr = r[RS];

===
mtctr

011111 RS 01001 00000 0111010011 0
0      6  11    16    21         31

    ctr = r[RS];

===
mulhw

011111 RT RA RB 0  001001011 Rc
0      6  11 16 21 22        31

    int64_t prod = (int64_t)(int32_t)r[RA] * (int64_t)(int32_t)r[RB];
    if(Rc) record(0, prod >> 32);
    r[RT] = prod >> 32;

===
mulhwu

011111 RT RA RB 0  000001011 Rc
0      6  11 16 21 22        31

    uint64_t prod = (uint64_t)r[RA] * (uint64_t)r[RB];
    if(Rc) record(0, (int64_t)prod >> 32);
    r[RT] = prod >> 32;

===
mulli

000111 RT RA SI
0      6  11 16

    r[RT] = r[RA] * (int16_t)SI;

===
mullw

011111 RT RA RB OE 011101011 Rc
0      6  11 16 21 22        31

    int64_t prod = (int64_t)(int32_t)r[RA] * (int64_t)(int32_t)r[RB];
    if(OE)
    {
        OV = (prod & 0xFFFFFFFF00000000) != 0
          && (prod & 0xFFFFFFFF00000000) != 0xFFFFFFFF00000000;
        SO = SO || OV;
    }
    if(Rc) record(0,prod);
    r[RT] = prod;

===

nand

011111 RS RA RB 0111011100 Rc
0      6  11 16 21         31

    uint32_t val = ~(r[RS] & r[RB]);
    r[RA] = val;
    if(Rc) record(0,val);

===

neg

011111 RT RA 00000 OE 001101000 Rc
0      6  11 16    21 22        31

    uint32_t val = ~r[RA] + 1;
    if(OE)
    {
        OV = val == 0x80000000;
        SO = SO || OV;
    }
    if(Rc) record(0,val);
    r[RT] = val;

===

nor

011111 RS RA RB 0001111100 Rc
0      6  11 16 21         31

    uint32_t val = ~(r[RS] | r[RB]);
    r[RA] = val;
    if(Rc) record(0,val);

===

or

011111 RS RA RB 0110111100 Rc
0      6  11 16 21         31

    uint32_t val = r[RS] | r[RB];
    r[RA] = val;
    if(Rc) record(0,val);

===

orc

011111 RS RA RB 0110011100 Rc
0      6  11 16 21         31

    uint32_t val = r[RS] | ~r[RB];
    r[RA] = val;
    if(Rc) record(0,val);

===

ori

01100 S RS RA UI
0     5 6  11 16

    uint32_t val = r[RS] | (UI << (S ? 16 : 0));
    r[RA] = val;

===

rlwimi

010100 RS RA SH MB ME Rc
0      6  11 16 21 26 31

    uint32_t in = r[RS];
    uint32_t rot = SH ? (in << SH) | (in >> (32-SH)) : in;
    uint32_t mask = 0xFFFFFFFFU >> MB;
    if(ME < MB)
        mask |= 0xFFFFFFFFU << (31-ME);
    else
        mask &= 0xFFFFFFFFU << (31-ME);
    uint32_t result = (rot & mask) | (r[RA] & ~mask);
    r[RA] = result;
    if(Rc) record(0,result);

===

rlwnm

0101 NOT_I 1 RS RA SH MB ME Rc
0    4     5 6  11 16 21 26 31

    uint32_t n = (NOT_I ? r[SH] : SH) & 31;
    uint32_t in = r[RS];
    uint32_t rot = n ? (in << n) | (in >> (32-n)) : in;
    uint32_t mask = 0xFFFFFFFFU >> MB;
    if(ME < MB)
        mask |= 0xFFFFFFFFU << (31-ME);
    else
        mask &= 0xFFFFFFFFU << (31-ME);
    uint32_t result = rot & mask;
    if(Rc) record(0,result);
    r[RA] = result;

===

slw

011111 RS RA RB 0000011000 Rc
0      6  11 16 21         31

    uint32_t n = r[RB] & 0x3F;
    uint32_t result;
    if(n & 0x20)
        result = 0;
    else
        result = r[RS] << n;
    if(Rc) record(0,result);
    r[RA] = result;

===

sraw

011111 RS RA SH 1100 I  11000 Rc
0      6  11 16 21   25 26    31

    uint32_t n = I ? SH : (r[SH] & 0x3F);
    uint32_t result;
    int32_t s = r[RS];
    if(n & 0x20)
    {
        if(s < 0)
        {
            result = 0xFFFFFFFF;
            CA = true;
        }
        else
        {
            result = 0;
            CA = false;
        }
    }
    else
    {
        CA = n != 0 && s < 0;
        result = s >> (int32_t)n;
    }

    if(Rc) record(0,result);
    r[RA] = result;

===

srw

011111 RS RA RB 1000011000 Rc
0      6  11 16 21         31

    uint32_t n = r[RB] & 0x3F;
    uint32_t result;
    uint32_t s = r[RS];
    if(n & 0x20)
        result = 0;
    else
        result = s >> n;

    if(Rc) record(0,result);
    r[RA] = result;


===

stb

10011 U RS RA D
0     5 6  11 16

    uint32_t ea = (RA ? r[RA] : 0) + (int16_t)D;
    store<uint8_t>(ea, r[RS]);
    if(U) r[RA] = ea;

===
stbx

011111 RS RA RB 0011 U  10111 0
0      6  11 16 21   25 26    31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    store<uint8_t>(ea, r[RS]);
    if(U) r[RA] = ea;

===
sth

10110 U RS RA D
0     5 6  11 16

    uint32_t ea = (RA ? r[RA] : 0) + (int16_t)D;
    store<uint16_t>(ea, r[RS]);
    if(U) r[RA] = ea;

===
sthx

011111 RS RA RB 0110 U  10111 0
0      6  11 16 21   25 26    31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    store<uint16_t>(ea, r[RS]);
    if(U) r[RA] = ea;

===
sthbrx

011111 RS RA RB 1110010110 0
0      6  11 16 21         31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    store<uint16_t>(ea, swap16(r[RS]));

===
stw

10010 U RS RA D
0     5 6  11 16

    uint32_t ea = (RA ? r[RA] : 0) + (int16_t)D;
    store<uint32_t>(ea, r[RS]);
    if(U) r[RA] = ea;

===
stwx

011111 RS RA RB 0010 U  10111 0
0      6  11 16 21   25 26    31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    store<uint32_t>(ea, r[RS]);
    if(U) r[RA] = ea;

===
stwbrx

011111 RS RA RB 1010010110 0
0      6  11 16 21         31

    uint32_t ea = (RA ? r[RA] : 0) + r[RB];
    store<uint32_t>(ea, swap32(r[RS]));

===

subf

011111 RT RA RB OE 000101000 Rc
0      6  11 16 21 22        31

    int64_t val = (int64_t)(int32_t)r[RA] + (int64_t)(int32_t)r[RB];
    r[RT] = val;
    if(OE) overflow(val);
    if(Rc) record(0,val);
  
===

subfc

011111 RT RA RB OE 000001000 Rc
0      6  11 16 21 22        31

    int64_t val = (int64_t)(int32_t)~r[RA] + (int64_t)(int32_t)r[RB] + 1;
    r[RT] = val;
    if(OE) overflow(val);
    if(Rc) record(0,val);
    CA = (val >> 32) & 1;
  
===

subfic

001000 RT RA SI
0      6  11 16

    int64_t val = (int64_t)(int32_t)~r[RA] + (int16_t)SI + 1;
    CA = (val >> 32) & 1;

===

subfme

011111 RT RA 00000 OE 011101000 Rc
0      6  11 16    21 22        31

    int64_t val = (int64_t)(int32_t)~r[RA] + (int64_t)-1 + (CA ? 1 : 0);
    r[RT] = val;
    if(OE) overflow(val);
    if(Rc) record(0,val);
    CA = (val >> 32) & 1;
  
===

subfze

011111 RT RA 00000 OE 011001010 Rc
0      6  11 16    21 22        31

    int64_t val = (int64_t)(int32_t)~r[RA] + (CA ? 1 : 0);
    r[RT] = val;
    if(OE) overflow(val);
    if(Rc) record(0,val);
    CA = (val >> 32) & 1;
  
===

xor

011111 RS RA RB 0100111100 Rc
0      6  11 16 21         31

    uint32_t val = r[RS] ^ r[RB];
    r[RA] = val;
    if(Rc) record(0,val);

===

xori

01101 S RS RA UI
0     5 6  11 16

    uint32_t val = r[RS] ^ (UI << (S ? 16 : 0));
    r[RA] = val;

===
